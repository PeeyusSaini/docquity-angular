# Copyright (c) 2012 Google Inc. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Notes:
#
# This generates makefiles suitable for inclusion into the Android build system
# via an Android.mk file. It is based on make.py, the standard makefile
# generator.
#
# The code below generates a separate .mk file for each target, but
# all are sourced by the top-level GypAndroid.mk.  This means that all
# variables in .mk-files clobber one another, and furthermore that any
# variables set potentially clash with other Android build system variables.
# Try to avoid setting global variables where possible.


import gyp
import gyp.common
import gyp.generator.make as make  # Reuse global functions from make backend.
import os
import re
import subprocess

generator_default_variables = {
    "OS": "android",
    "EXECUTABLE_PREFIX": "",
    "EXECUTABLE_SUFFIX": "",
    "STATIC_LIB_PREFIX": "lib",
    "SHARED_LIB_PREFIX": "lib",
    "STATIC_LIB_SUFFIX": ".a",
    "SHARED_LIB_SUFFIX": ".so",
    "INTERMEDIATE_DIR": "$(gyp_intermediate_dir)",
    "SHARED_INTERMEDIATE_DIR": "$(gyp_shared_intermediate_dir)",
    "PRODUCT_DIR": "$(gyp_shared_intermediate_dir)",
    "SHARED_LIB_DIR": "$(builddir)/lib.$(TOOLSET)",
    "LIB_DIR": "$(obj).$(TOOLSET)",
    "RULE_INPUT_ROOT": "%(INPUT_ROOT)s",  # This gets expanded by Python.
    "RULE_INPUT_DIRNAME": "%(INPUT_DIRNAME)s",  # This gets expanded by Python.
    "RULE_INPUT_PATH": "$(RULE_SOURCES)",
    "RULE_INPUT_EXT": "$(suffix $<)",
    "RULE_INPUT_NAME": "$(notdir $<)",
    "CONFIGURATION_NAME": "$(GYP_CONFIGURATION)",
}

# Make supports multiple toolsets
generator_supports_multiple_toolsets = True


# Generator-specific gyp specs.
generator_additional_non_configuration_keys = [
    # Boolean to declare that this target does not want its name mangled.
    "android_unmangled_name",
    # Map of android build system variables to set.
    "aosp_build_settings",
]
generator_additional_path_sections = []
generator_extra_sources_for_rules = []


ALL_MODULES_FOOTER = """\
# "gyp_all_modules" is a concatenation of the "gyp_all_modules" targets from
# all the included sub-makefiles. This is just here to clarify.
gyp_all_modules:
"""

header = """\
# This file is generated by gyp; do not edit.

"""

# Map gyp target types to Android module classes.
MODULE_CLASSES = {
    "static_library": "STATIC_LIBRARIES",
    "shared_library": "SHARED_LIBRARIES",
    "executable": "EXECUTABLES",
}


def IsCPPExtension(ext):
    return make.COMPILABLE_EXTENSIONS.get(ext) == "cxx"


def Sourceify(path):
    """Convert a path to its source directory form. The Android backend does not
    support options.generator_output, so this function is a noop."""
    return path


# Map from qualified target to path to output.
# For Android, the target of these maps is a tuple ('static', 'modulename'),
# ('dynamic', 'modulename'), or ('path', 'some/path') instead of a string,
# since we link by module.
target_outputs = {}
# Map from qualified target to any linkable output.  A subset
# of target_outputs.  E.g. when mybinary depends on liba, we want to
# include liba in the linker line; when otherbinary depends on
# mybinary, we just want to build mybinary first.
target_link_deps = {}


class AndroidMkWriter:
    """AndroidMkWriter packages up the writing of one target-specific Android.mk.

    Its only real entry point is Write(), and is mostly used for namespacing.
    """

    def __init__(self, android_top_dir):
        self.android_top_dir = android_top_dir

    def Write(
        self,
        qualified_target,
        relative_target,
        base_path,
        output_filename,
        spec,
        configs,
        part_of_all,
        write_alias_target,
        sdk_version,
    ):
        """The main entry point: writes a .mk file for a single target.

        Arguments:
          qualified_target: target we're generating
          relative_target: qualified target name relative to the root
          base_path: path relative to source root we're building in, used to resolve
                     target-relative paths
          output_filename: output .mk file name to write
          spec, configs: gyp info
          part_of_all: flag indicating this target is part of 'all'
          write_alias_target: flag indicating whether to create short aliases for
                              this target
          sdk_version: what to emit for LOCAL_SDK_VERSION in output
        """
        gyp.common.EnsureDirExists(output_filename)

        self.fp = open(output_filename, "w")

        self.fp.write(header)

        self.qualified_target = qualified_target
        self.relative_target = relative_target
        self.path = base_path
        self.target = spec["target_name"]
        self.type = spec["type"]
        self.toolset = spec["toolset"]

        deps, link_deps = self.ComputeDeps(spec)

        # Some of the generation below can add extra output, sources, or
        # link dependencies.  All of the out params of the functions that
        # follow use names like extra_foo.
        extra_outputs = []
        extra_sources = []

        self.android_class = MODULE_CLASSES.get(self.type, "GYP")
        self.android_module = self.ComputeAndroidModule(spec)
        (self.android_stem, self.android_suffix) = self.ComputeOutputParts(spec)
        self.output = self.output_binary = self.ComputeOutput(spec)

        # Standard header.
        self.WriteLn("include $(CLEAR_VARS)\n")

        # Module class and name.
        self.WriteLn("LOCAL_MODULE_CLASS := " + self.android_class)
        self.WriteLn("LOCAL_MODULE := " + self.android_module)
        # Only emit LOCAL_MODULE_STEM if it's different to LOCAL_MODULE.
        # The library module classes fail if the stem is set. ComputeOutputParts
        # makes sure that stem == modulename in these cases.
        if self.android_stem != self.android_module:
            self.WriteLn("LOCAL_MODULE_STEM := " + self.android_stem)
        self.WriteLn("LOCAL_MODULE_SUFFIX := " + self.android_suffix)
        if self.toolset == "host":
            self.WriteLn("LOCAL_IS_HOST_MODULE := true")
            self.WriteLn("LOCAL_MULTILIB := $(GYP_HOST_MULTILIB)")
        elif sdk_version > 0:
            self.WriteLn(
                "LOCAL_MODULE_TARGET_ARCH := " "$(TARGET_$(GYP_VAR_PREFIX)ARCH)"
            )
            self.WriteLn("LOCAL_SDK_VERSION := %s" % sdk_version)

        # Grab output directories; needed for Actions and Rules.
        if self.toolset == "host":
            self.WriteLn(
                "gyp_intermediate_dir := "
                "$(call local-intermediates-dir,,$(GYP_HOST_VAR_PREFIX))"
            )
        else:
            self.WriteLn(
                "gyp_intermediate_dir := "
                "$(call local-intermediates-dir,,$(GYP_VAR_PREFIX))"
            )
        self.WriteLn(
            "gyp_shared_intermediate_dir := "
            "$(call intermediates-dir-for,GYP,shared,,,$(GYP_VAR_PREFIX))"
        )
        self.WriteLn()

        # List files this target depends on so that actions/rules/copies/sources
        # can depend on the list.
        # TODO: doesn't pull in things through transitive link deps; needed?
        target_dependencies = [x[1] for x in deps if x[0] == "path"]
        self.WriteLn("# Make sure our deps are built first.")
        self.WriteList(
            target_dependencies, "GYP_TARGET_DEPENDENCIES", local_pathify=True
        )

        # Actions must come first, since they can generate more OBJs for use below.
        if "actions" in spec:
            self.WriteActions(spec["actions"], extra_sources, extra_outputs)

        # Rules must be early like actions.
        if "rules" in spec:
            self.WriteRules(spec["rules"], extra_sources, extra_outputs)

        if "copies" in spec:
            self.WriteCopies(spec["copies"], extra_outputs)

        # GYP generated outputs.
        self.WriteList(extra_outputs, "GYP_GENERATED_OUTPUTS", local_pathify=True)

        # Set LOCAL_ADDITIONAL_DEPENDENCIES so that Android's build rules depend
        # on both our dependency targets and our generated files.
        self.WriteLn("# Make sure our deps and generated files are built first.")
        self.WriteLn(
            "LOCAL_ADDITIONAL_DEPENDENCIES := $(GYP_TARGET_DEPENDENCIES) "
            "$(GYP_GENERATED_OUTPUTS)"
        )
        self.WriteLn()

        # Sources.
        if spec.get("sources", []) or extra_sources:
            self.WriteSources(spec, configs, extra_sources)

        self.WriteTarget(
            spec, configs, deps, link_deps, part_of_all, write_alias_target
        )

        # Update global list of target outputs, used in dependency tracking.
        target_outputs[qualified_target] = ("path", self.output_binary)

        # Update global list of link dependencies.
        if self.type == "static_library":
            target_link_deps[qualified_target] = ("static", self.android_module)
        elif self.type == "shared_library":
            target_link_deps[qualified_target] = ("shared", self.android_module)

        self.fp.close()
        return self.android_module

    def WriteActions(self, actions, extra_sources, extra_outputs):
        """Write Makefile code for any 'actions' from the gyp input.

        extra_sources: a list that will be filled in with newly generated source
                       files, if any
        extra_outputs: a list that will be filled in with any outputs of these
                       actions (used to make other pieces dependent on these
                       actions)
        """
        for action in actions:
            name = make.StringToMakefileVariable(
                "{}_{}".format(self.relative_target, action["action_name"])
            )
            self.WriteLn('### Rules for action "%s":' % action["action_name"])
            inputs = action["inputs"]
            outputs = action["outputs"]

            # Build up a list of outputs.
            # Collect the output dirs we'll need.
            dirs = set()
            for out in outputs:
                if not out.startswith("$"):
                    print(
                        'WARNING: Action for target "%s" writes output to local path '
                        '"%s".' % (self.target, out)
                    )
                dir = os.path.split(out)[0]
                if dir:
                    dirs.add(dir)
            if int(action.get("process_outputs_as_sources", False)):
                extra_sources += outputs

            # Prepare the actual command.
            command = gyp.common.EncodePOSIXShellList(action["action"])
            if "message" in action:
                quiet_cmd = "Gyp action: %s ($@)" % action["message"]
            else:
                quiet_cmd = "Gyp action: %s ($@)" % name
            if len(dirs) > 0:
                command = "mkdir -p %s" % " ".join(dirs) + "; " + command

            cd_action = "cd $(gyp_local_path)/%s; " % self.path
            command = cd_action + command

            # The makefile rules are all relative to the top dir, but the gyp actions
            # are defined relative to their containing dir.  This replaces the gyp_*
            # variables for the action rule with an absolute version so that the
            # output goes in the right place.
            # Only write the gyp_* rules for the "primary" output (:1);
            # it's superfluous for the "extra outputs", and this avoids accidentally
            # writing duplicate dummy rules for those outputs.
            main_output = make.QuoteSpaces(self.LocalPathify(outputs[0]))
            self.WriteLn("%s: gyp_local_path := $(LOCAL_PATH)" % main_output)
            self.WriteLn("%s: gyp_var_prefix := $(GYP_VAR_PREFIX)" % main_output)
            self.WriteLn(
                "%s: gyp_intermediate_dir := "
                "$(abspath $(gyp_intermediate_dir))" % main_output
            )
            self.WriteLn(
                "%s: gyp_shared_intermediate_dir := "
                "$(abspath $(gyp_shared_intermediate_dir))" % main_output
            )

            # Android's envsetup.sh adds a number of directories to the path including
            # the built host binary directory. This causes actions/rules invoked by
            # gyp to sometimes use these instead of system versions, e.g. bison.
            # The built host binaries may not be suitable, and can cause errors.
            # So, we remove them from the PATH using the ANDROID_BUILD_PATHS variable
            # set by envsetup.
            self.WriteLn(
                "%s: export PATH := $(subst $(ANDROID_BUILD_PATHS),,$(PATH))"
                % main_output
            )

            # Don't allow spaces in input/output filenames, but make an exception for
            # filenames which start with '$(' since it's okay for there to be spaces
            # inside of make function/m